[ title ]
the Linux From Scratch (LFS) image building system


[ overview ]

LFS is customisable tool automating the creation of 'LINUX from
scratch' based disk images. The target system is described by 3
components:

. a _board_ describes the target plateform and software version
and configuration to use,
. a set of _softwares_ and packages, as well as the method to retrieve
build and install them if required by the board configuration,
. an _environment_ that is used to setup the target system according
to its operating context.

LFS is currently implemented as a monolithic but configurable BASH
script and runs on a LINUX host.


[ design goals ]

LFS has been designed with the following goals in mind:
. the core engine source code must be monolithic yet fully tunable.
. keep the system simple. esp. adding a new board or software must
be simple and done in a centralized location, with a minimum amount
of effort and limited redundancy,
. for the common case, the user must not perform action of its own.
He must describe what to do to the engine. This is done by passing
established variables from and to the engine,
. in case the description process is not enough, the user should
still be able to bypass the engine and execute commands itself. In
this case, he must be able to rely on the engine context and internal
routine to avoid implementing too much code.


[ theory of operation ]

the main script is:
sh/do_lfs.sh

it is run with:
LFS_THIS_BOARD_NAME={comex,rpib} \
LFS_THIS_ENV_NAME={esrf,home} \
$LFS_TOP_DIR/sh/do_lfs.sh

$LFS_TOP_DIR is set to the LFS topmost directory.

first, LFS sources the default global configuration in:
$LFS_TOP_DIR/sh/do_default_globals.sh

the following variables are set to default values:
LFS_WORK_DIR: the working directory path
LFS_TAR_DIR: the directory to rertieve tarballs
LFS_SRC_DIR: the directory to extract tarballs
LFS_TARGET_INSTALL_DIR: the target system rootfs mountpoint
LFS_HOST_INSTALL_DIR: the directory used to install host softwares
LFS_BUILD_DIR: the directory used to build softwares
LFS_CROSS_COMPILE: the toolchain compilation prefix
LFS_HOST_ARCH: the host architecture
LFS_DISK_DEV: the disk image device path
LFS_DISK_IMAGE: the disk image file path
LFS_DISK_EMPTY_SIZE: the disk empty partition size, in MB
LFS_DISK_BOOT_SIZE: the dist boot partition size, in MB
LFS_DISK_ROOT_SIZE: the disk root partition size, in MB

then, it sources user specific global configuration in:
$LFS_TOP_DIR/sh/do_user_globals.sh
this file may overrides one of the previous variable, and set
user specific variables (proxy settings ...)

then, the board configuration is sourced in:
$LFS_TOP_DIR/board/$LFS_THIS_BOARD_NAME/do_conf.sh

It is used to set correct partition sizes:
LFS_DISK_EMPTY_SIZE=
LFS_DISK_BOOT_SIZE=
LFS_DISK_ROOT_SIZE=

A missing or zero sized partition will not be present in the image.


It is used to set a correct toolchain and architecture for the target
platform:
LFS_TARGET_ARCH=
LFS_CROSS_CROMPILE=

Finally, it is used to select the software versions:
LFS_LINUX_VERS=
LFS_PCIUTILS_VERS=
...

Then, the root filesystem is installed. Enabled softwares are
retrieved, configured, built and installed. This process is detailed
in the section:
software installation process

Then, the environment configuration is applied. To do so, the script:
$LFS_TOP_DIR/env/$LFS_THIS_ENV_NAME/do_post_rootfs.sh
is executed. This script handles tasks such as user creation, network
setup, filesystems mounts ...

Then, the disk image is finalized and available at:
$LFS_DISK_IMAGE
It can be put into a physical disk, for instance using the LINUX _dd_
command.


[[ software installation process ]]

The software installation process iterates over subdirectories in:
$LFS_TOP_DIR/soft

For each directory, it sources the file:
do_conf.sh

This file sets the following variables:
LFS_THIS_SOFT_IS_ENABLED={0,1}: set to 1 if the software is to be
installed,
LFS_THIS_SOFT_DEPS='xxx yyy ...': the name of softwares that must be
installed before the software can be installed itself.
LFS_THIS_SOFT_URL: the url the software tarball can be retrieved at.
the following schemes are supported: file://, http://, https://,
ftp://
LFS_IS_CROSS_COMPILED={0,1}: set to 0 if the software is compiled
for the host system. 

If a given software is enabled, the installation process is then
divided into 3 stages:
. pre_build, the preparing stage,
. build, the build stage,
. post_build, the finalistion stage.

these stages can be configured by variables specified in do_conf.sh,
or fully driven by dedicated scripts, as explained in the following
sections. The reason to split the installation is to minimize the
overall efforts required if a software specific operations must be
performed at a particular stage. For instance, finalizing dropbear
installation requires creating symlinks manually, but preparing and
building are automatically handled.

. the pre_build stage
do whatever is needed to prepare the install process. the variable:
LFS_THIS_SOFT_PREBUILD_METHOD={autotools,kbuild}
may be set to indicate a default method to use.
if 'autotools' is used, the sequence ./bootstrap and ./configure is
used to prepare the build process.
if 'kbuild' is used, the file:
$LFS_TOP_DIR/board/$LFS_BOARD_NAME/$LFS_THIS_SOFT_NAME-$LFS_THIS_SOFT_VERS.config
is copied (linux kernel, busybox, crosstool-ng)

In both cases, the arrays:
LFS_THIS_SOFT_PRE_BUILD_ARG[]
LFS_THIS_SOFT_PRE_BUILD_ENV[]
can be used to pass values to the preparing stage.

if LFS_THIS_SOFT_PRE_BUILD_METHOD is left empty, the script:
do_pre_build.sh
is executed if existing. Otherwise, nothing is done.

. the build stage
mainly consists of compiling the sources. the variable:
LFS_THIS_SOFT_BUILD_METHOD={make}
may be set to indicate the compilation method. In this
case, make is run and the arrays:
LFS_THIS_SOFT_BUILD_ARG[]
LFS_THIS_SOFT_BUILD_ENV[]
can be used to pass values to the process.
if LFS_THIS_SOFT_BUILD_METHOD is empty, the script:
do_build.sh
is executed if existing. otherwise, nothing is done.

. the post_build stage
finalize the installation procedure. it mostly consists of installing
the binaries and configuration files. the variable:
LFS_THIS_SOFT_POST_BUILD_METHOD={make_install}
may be set to indicate the installation method, in which
case make install is run. in this case, the arrays:
LFS_THIS_SOFT_POST_BUILD_ARG[]
LFS_THIS_SOFT_POST_BUILD_ENV[]
can be used to pass values to the process.
if LFS_THIS_SOFT_POST_BUILD_METHOD is empty, the script:
do_post_build.sh
is executed if existing. otherwise, nothing is done.


[ acknowledgements ]

This project was started as a way to build embedded systems for
LINUX based plateforms engineered at the ESRF (http://www.esrf.eu).
At the same time, I was implementing a similar tool for RASPBERRYPI
boards, so I decided to merge the efforts.

As of 2013, you can contact me at:
fabien.lementec@gmail.com (private email address)
lementec@esrf.fr (company email address)
