[ title ]

LFS, a tool to build Linux From Scratch based images


[ overview ]

LFS is customisable tool automating the creation of 'LINUX from
scratch' based disk images. The target system is described by 3
components:

. a _board_ describes the target plateform and software version
and configuration to use,
. a set of _softwares_ and packages, as well as the method to retrieve
build and install them if required by the board configuration,
. an _environment_ that is used to setup the target system according
to its operating context.

LFS is currently implemented as a monolithic but configurable BASH
script and runs on a LINUX host.


[ design notes ]

LFS has been designed with the following goals in mind:

. the core engine source code must be easy to understand, so that
the code is part of the documentation. the number of source files
is limited, keeping LFS monolithic yet fully tunable.

. tunning must not require LFS source modification. tuning is done
by passing variable to and from scripts sourced or executed by the
core. the exported and required variables must be well known, and
all start with the LFS_ prefix.

. common operations, such as adding a new software, must be simple
and must require a very limited amount of effort.

. specific operations must be possible, for instance, installing a
software in a special location. it requires the execution of a user
written script. in this case, all the LFS context is exported to the
script. LFS_ variables and internal routines can be used, limiting
the code redundancy.


[ theory of operation ]

this section describes the sequencing done by LFS.

the main script is:
sh/do_lfs.sh

it is run with:
LFS_THIS_BOARD_NAME={comex,rpib} \
LFS_THIS_ENV_NAME={esrf,home} \
$LFS_TOP_DIR/sh/do_lfs.sh

$LFS_TOP_DIR is set to the LFS topmost directory.

first, LFS sources the default global configuration in:
$LFS_TOP_DIR/sh/do_default_globals.sh

the following variables are set to default values:
LFS_WORK_DIR: the working directory path
LFS_TAR_DIR: the directory to rertieve tarballs
LFS_SRC_DIR: the directory to extract tarballs
LFS_TARGET_INSTALL_DIR: the target system rootfs mountpoint
LFS_HOST_INSTALL_DIR: the directory used to install host softwares
LFS_BUILD_DIR: the directory used to build softwares
LFS_CROSS_COMPILE: the toolchain compilation prefix
LFS_HOST_ARCH: the host architecture
LFS_DISK_DEV: the disk image device path
LFS_DISK_IMAGE: the disk image file path
LFS_DISK_EMPTY_SIZE: the disk empty partition size, in MB
LFS_DISK_BOOT_SIZE: the dist boot partition size, in MB
LFS_DISK_ROOT_SIZE: the disk root partition size, in MB

then, it sources user specific global configuration in:
$LFS_TOP_DIR/sh/do_user_globals.sh
this file may overrides one of the previous variable, and set
user specific variables (proxy settings ...)

then, the board configuration is sourced in:
$LFS_TOP_DIR/board/$LFS_THIS_BOARD_NAME/do_conf.sh

It is used to set partition sizes and types:
LFS_DISK_EMPTY_SIZE=
LFS_DISK_BOOT_SIZE=
LFS_DISK_BOOT_FS_TYPE={vfat,ext2}
LFS_DISK_ROOT_SIZE=
LFS_DISK_ROOT_FS_TYPE={vfat,ext2}

A missing or zero sized partition will not be present in the image.

Note that the partition are created in this order:
empty
boot
root

The board configuration script should also set a correct toolchain and
architecture for the target platform:
LFS_TARGET_ARCH=
LFS_CROSS_CROMPILE=

Finally, it is used to select the software versions:
LFS_LINUX_VERS=
LFS_PCIUTILS_VERS=
...

Then, the root filesystem is installed. Enabled softwares are
retrieved, configured, built and installed. This process is detailed
in the section:
software installation process

Then, the environment configuration is applied. To do so, the script:
$LFS_TOP_DIR/env/$LFS_THIS_ENV_NAME/do_post_rootfs.sh
is executed. This script handles tasks such as user creation, network
setup, filesystems mounts ...

Then, the disk image is finalized and available at:
$LFS_DISK_IMAGE
It can be put into a physical disk, for instance using the LINUX _dd_
command:
$> dd if=$LFS_DISK_IMAGE of=/dev/sdX bs=1024

*NOTE*: after this command, the SDCARD must be removed and reinsert for
the kernel to see the new partition layout. otherwise, trying to mount
one of the /dev/sdX partition will probably fail.


[[ software installation process ]]

The software installation process iterates over subdirectories in:
$LFS_TOP_DIR/soft

For each directory, it sources the file:
do_conf.sh

This file sets the following variables:
LFS_THIS_SOFT_IS_ENABLED={0,1}: set to 1 if the software is to be
installed,
LFS_THIS_SOFT_DEPS='xxx yyy ...': the name of softwares that must be
installed before the software can be installed itself.
*NOTE*: this will be replaced by LFS_THIS_SOFT_DEP[], an array containing
containing a list of dependencies.
LFS_THIS_SOFT_URL: the url the software tarball can be retrieved at.
*NOTE*: this will be replaced by LFS_THIS_SOFT_URL[], an array containing
a list of possible urls.
LFS_IS_CROSS_COMPILED={0,1}: set to 0 if the software is compiled
for the host system. 

If a given software is enabled, an url is given and the tarball does
not already exist, the source tarball is retrieved from:
$LFS_THIS_SOFT_URL

into the directory:
$LFS_TAR_DIR

the following schemes are supported:
file://
http://
https://
ftp://
git:// (not implemented)
svn:// (not implemented)

the following extensions are supported:
tar
tar.gz
tgz
tar.bz2
xz (not implemented)

then, if the source does not already exist, the tarball is extracted
in the directory:
$LFS_SRC_DIR/$LFS_THIS_SOFT_NAME

A build directory is created:
$LFS_BUILD_DIR/$LFS_THIS_SOFT_NAME

If the build directory already exist, the software installation
process stops. Otherwise, the installation process is then divided
into 3 stages:
. pre_build, the preparing stage,
. build, the build stage,
. post_build, the finalistion stage.

these stages can be configured by variables specified in do_conf.sh,
or fully driven by dedicated scripts, as explained in the following
sections. The reason to split the installation is to minimize the
overall efforts required if a software specific operations must be
performed at a particular stage. For instance, finalizing dropbear
installation requires creating symlinks manually, but preparing and
building are automatically handled.

. the pre_build stage
do whatever is needed to prepare the install process. the variable:
LFS_THIS_SOFT_PREBUILD_METHOD={autotools,kbuild}
may be set to indicate a default method to use.
if 'autotools' is used, the sequence ./bootstrap and ./configure is
used to prepare the build process.
if 'kbuild' is used, the file:
$LFS_TOP_DIR/board/$LFS_BOARD_NAME/$LFS_THIS_SOFT_NAME-$LFS_THIS_SOFT_VERS.config
is copied (linux kernel, busybox, crosstool-ng)

In both cases, the arrays:
LFS_THIS_SOFT_PRE_BUILD_ARG[]
LFS_THIS_SOFT_PRE_BUILD_ENV[]
can be used to pass values to the preparing stage.

if LFS_THIS_SOFT_PRE_BUILD_METHOD is left empty, the script:
do_pre_build.sh
is executed if existing. Otherwise, nothing is done.

. the build stage
mainly consists of compiling the sources. the variable:
LFS_THIS_SOFT_BUILD_METHOD={make}
may be set to indicate the compilation method. In this
case, make is run and the arrays:
LFS_THIS_SOFT_BUILD_ARG[]
LFS_THIS_SOFT_BUILD_ENV[]
can be used to pass values to the process.
if LFS_THIS_SOFT_BUILD_METHOD is empty, the script:
do_build.sh
is executed if existing. otherwise, nothing is done.

. the post_build stage
finalize the installation procedure. it mostly consists of installing
the binaries and configuration files. the variable:
LFS_THIS_SOFT_POST_BUILD_METHOD={make_install}
may be set to indicate the installation method, in which
case make install is run. in this case, the arrays:
LFS_THIS_SOFT_POST_BUILD_ARG[]
LFS_THIS_SOFT_POST_BUILD_ENV[]
can be used to pass values to the process.
if LFS_THIS_SOFT_POST_BUILD_METHOD is empty, the script:
do_post_build.sh
is executed if existing. otherwise, nothing is done.


[ contact ]

fabien.lementec@gmail.com
texane@gmail.com
